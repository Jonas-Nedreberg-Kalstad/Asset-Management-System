trigger:
- main

pool:
  name: Localhost
  demands:
    - maven
    - docker

variables:
  tag: $(Build.SourceVersion) # The commit hash of the current project head.
  group: AUTHENTICATION

jobs:

###### BuildAndTest ###################################################################################################################################

- job: BuildAndTest
  displayName: Build and Test Spring Boot App
  
  
  
  steps:

  # Tests and then builds the maven project.
  - task: Maven@3
    inputs:
      mavenPomFile: backend/pom.xml
      goals: clean package
      javaHomeOption: JDKVersion
      mavenVersionOption: Default
      mavenAuthenticateFeed: false
      effectivePomSkip: false
      sonarQubeRunAnalysis: false
    env:
      DATABASE_URL: "localhost"
      DATABASE_USERNAME: "root"
      DATABASE_PASSWORD: "root"

  # Code coverage is done via JaCoCo, which creates a report over what code is covered with tests or not.
  - task: PublishCodeCoverageResults@2
    displayName: Publishes the code coverage results
    inputs:
      summaryFileLocation: $(Build.SourcesDirectory)/backend/target/site/jacoco/jacoco.xml

###### Dockerize ######################################################################################################################################

- job: Dockerize
  displayName: Dockerize the spring boot application jar file
  dependsOn: BuildAndTest
  
  steps:
  - checkout: none

  # Creates a docker image and then runs a container.
  - task: Docker@2
    inputs:
      repository: ams-backend
      command: build
      Dockerfile: backend/Dockerfile
      tags: $(tag)

  # Runs a docker container with the image created above.
  - script: |
      docker run --name ams-backend -d -p 8080:8080 -e DATABASE_URL=ams-db -e DATABASE_USERMAME=root -e DATABASE_PASSWORD=root --network ams-network ams-backend:$(tag)
    displayName: Run Docker container

####### TestingAPI #####################################################################################################################################
#
#- job: TestingAPI
#  displayName: Tests if the APIs function as expected on the docker container
#  dependsOn: Dockerize
#  
#  steps:
#  - checkout: none
#
#  # initializes the directory for testresults and runs the JMeter test script.
#  - script: |
#      mkdir $(Build.SourcesDirectory)\JMeterTestReport\api\apiTestReport
#      jmeter -n -t $(Build.SourcesDirectory)/spring-boot-application-api-test.jmx -l $(Build.SourcesDirectory)/JMeterTestReport/api/ApiTest.xml -e -o $(Build.SourcesDirectory)/JMeterTestReport/api/apiTestReport/
#    displayName: Run TestApi JMeter script
#
#  # Python script which converts JMeter .xml format to JUnit .xml format, downloaded from git repository:
#  # https://github.com/Azure-Samples/jmeter-aci-terraform/blob/main/scripts/jtl_junit_converter.py
#  # IT IS A TOOL I DID NOT CREATE, author of this tool is git user: @davidmiguelalves
#  - script: |
#      curl https://raw.githubusercontent.com/Azure-Samples/jmeter-aci-terraform/main/scripts/jtl_junit_converter.py -o $(Build.SourcesDirectory)\jtl_junit_converter.py
#    displayName: Download xml formater, JMeter.xml to JUnit.xml format
#  
#  # converts the JMeter .jtl output from the test to a .xml file in JUnit standard via
#  # the python script downloaded earlier for displaying it in the azure tests tab.
#  - script: |
#      py jtl_junit_converter.py $(Build.SourcesDirectory)/JMeterTestReport/api/ApiTest.xml ApiTest.xml
#    displayName: Convert ApiTest.xml format
#  
#  # Publishes the results from the api, in the tests tab.
#  - task: PublishTestResults@2
#    inputs:
#      testResultsFormat: JUnit
#      testResultsFiles: $(Build.SourcesDirectory)/ApiTest.xml
#      testRunTitle: Api Test Results
#    displayName: Publishes API test results
#  
#  # Publishes the JMeter test report as an artifact so it can be downloaded and viewed.
#  - task: PublishBuildArtifacts@1
#    inputs:
#      PathtoPublish: $(Build.SourcesDirectory)/JMeterTestReport/api/apiTestReport/
#      ArtifactName: JMeter Api test results
#      publishLocation: Container
#    displayName: 'Upload JMeter Api test report'
#
####### TestingPerformance #############################################################################################################################
#
#- job: TestingPerformance
#  displayName: Tests the performance of the server apis
#  dependsOn: TestingAPI
#  
#  steps:
#  - checkout: none
#  
#  # initializes the directory for testresults and runs the JMeter test script.
#  - script: |
#      mkdir $(Build.SourcesDirectory)\JMeterTestReport\performance\performanceTestReport
#      jmeter -n -t $(Build.SourcesDirectory)/spring-boot-application-performance-test.jmx -l $(Build.SourcesDirectory)/JMeterTestReport/performance/PerformanceTest.xml -e -o $(Build.SourcesDirectory)/JMeterTestReport/performance/performanceTestReport/
#    displayName: Run TestApi JMeter script
#
#  # converts the JMeter .jtl output from the test to a .xml file in JUnit standard via
#  # the python script downloaded earlier for displaying it in the azure tests tab.
#  - script: |
#      py jtl_junit_converter.py $(Build.SourcesDirectory)/JMeterTestReport/performance/PerformanceTest.xml PerformanceTest.xml
#    displayName: Convert PerformanceTest.xml format
#  
#  # Publishes the results from the performance tests, in the tests tab.
#  - task: PublishTestResults@2
#    inputs:
#      testResultsFormat: JUnit
#      testResultsFiles: $(Build.SourcesDirectory)/PerformanceTest.xml
#      testRunTitle: Performance Test Results
#    displayName: Publishes performance test results
#  
#  # Publishes the JMeter test report as an artifact so it can be downloaded and viewed.
#  - task: PublishBuildArtifacts@1
#    inputs:
#      PathtoPublish: $(Build.SourcesDirectory)/JMeterTestReport/performance/performanceTestReport/
#      ArtifactName: JMeter performance test results
#      publishLocation: Container
#    displayName: 'Upload JMeter performance test report'
#
####### Deploy ##########################################################################################################################################

- job: DeployAzureResourcesWithTerraform
  dependsOn: 
  - BuildAndTest
  displayName: 'Deploy Azure Resources With Terraform'
  steps:
  - checkout: self  # Checks out the source code into the agent

  - script: |
      az login --service-principal -u $(ARM_CLIENT_ID) -p $(ARM_CLIENT_SECRET) --tenant $(ARM_TENANT_ID)
      "C:\Terraform\terraform" init
    displayName: 'Initialize Terraform'
    env:
      ARM_CLIENT_ID: '$(ARM_CLIENT_ID)'
      ARM_CLIENT_SECRET: '$(ARM_CLIENT_SECRET)'
      ARM_SUBSCRIPTION_ID: '$(ARM_SUBSCRIPTION_ID)'
      ARM_TENANT_ID: '$(ARM_TENANT_ID)'

  - script: |
      "C:\Terraform\terraform" destroy -target=azurerm_linux_virtual_machine.deploy-vm -auto-approve
    displayName: 'Tear down only Linux VM'   
    env:
      ARM_CLIENT_ID: '$(ARM_CLIENT_ID)'
      ARM_CLIENT_SECRET: '$(ARM_CLIENT_SECRET)'
      ARM_SUBSCRIPTION_ID: '$(ARM_SUBSCRIPTION_ID)'
      ARM_TENANT_ID: '$(ARM_TENANT_ID)'

  - script: |
      "C:\Terraform\terraform" plan -out=tfplan
    displayName: 'Plan Terraform Deployment'
    env:
      ARM_CLIENT_ID: $(ARM_CLIENT_ID)
      ARM_CLIENT_SECRET: $(ARM_CLIENT_SECRET)
      ARM_SUBSCRIPTION_ID: $(ARM_SUBSCRIPTION_ID)
      ARM_TENANT_ID: $(ARM_TENANT_ID)


  - script: |
      "C:\Terraform\terraform" apply -auto-approve -var="jwt_secret_key=$(JWT_SECRET_KEY)" -var="ACRPASSWORD=$(ACRPASSWORD)"
    displayName: 'Apply Terraform Deployment'
    env:
      ARM_CLIENT_ID: '$(ARM_CLIENT_ID)'
      ARM_CLIENT_SECRET: '$(ARM_CLIENT_SECRET)'
      ARM_SUBSCRIPTION_ID: '$(ARM_SUBSCRIPTION_ID)'
      ARM_TENANT_ID: '$(ARM_TENANT_ID)'

####### Clean ##########################################################################################################################################

# Clean always runs wether the pipeline fails or not.
# Deletes the docker images built, and running docker containers.
- job: Clean
  displayName: Clean docker
  dependsOn: 
    - BuildAndTest
    - Dockerize
  condition: always()

  steps:
  # Deletes the docker image.
  - script: |
        docker rm --force ams-backend
    displayName: Deletes the running container

  # Deletes the docker container.
  - script: |
      docker rmi ams-backend:$(tag)
    displayName: Remove docker image on agent