trigger:
- main

pool:
  name: Localhost
  demands:
    - maven
    - docker

variables:
  tag: $(Build.SourceVersion) # The commit hash of the current project head.

jobs:

###### BuildAndTest ###################################################################################################################################

- job: BuildAndTest
  displayName: Build and Test Spring Boot App
  
  
  
  steps:

  - script: |
      set $env:DATABASE_URL = "localhost"
      set $env:DATABASE_USERNAME = "root"
      set $env:DATABASE_PASSWORD = "root"
    displayName: set environment variables

  # Tests and then builds the maven project.
  - task: Maven@3
    inputs:
      mavenPomFile: backend/pom.xml
      goals: clean package
      javaHomeOption: JDKVersion
      mavenVersionOption: Default
      mavenAuthenticateFeed: false
      effectivePomSkip: false
      sonarQubeRunAnalysis: false

  # Code coverage is done via JaCoCo, which creates a report over what code is covered with tests or not.
  - task: PublishCodeCoverageResults@2
    displayName: Publishes the code coverage results
    inputs:
      summaryFileLocation: $(Build.SourcesDirectory)/backend/target/site/jacoco/jacoco.xml

###### Dockerize ######################################################################################################################################

- job: Dockerize
  displayName: Dockerize the spring boot application jar file
  dependsOn: BuildAndTest
  
  steps:
  - checkout: none

  # Creates a docker image and then runs a container.
  - task: Docker@2
    inputs:
      repository: ams-backend
      command: build
      Dockerfile: backend/Dockerfile
      tags: $(tag)

  # Runs a docker container with the image created above.
  - script: |
      docker run --name spring-boot-app -d -p 8080:8080 -e DATABASE_URL=ams-db -e DATABASE_USERMAME=root -e DATABASE_PASSWORD=root --network ams-network ams-backend:$(tag)
    displayName: Run Docker container

####### TestingAPI #####################################################################################################################################
#
#- job: TestingAPI
#  displayName: Tests if the APIs function as expected on the docker container
#  dependsOn: Dockerize
#  
#  steps:
#  - checkout: none
#
#  # initializes the directory for testresults and runs the JMeter test script.
#  - script: |
#      mkdir $(Build.SourcesDirectory)\JMeterTestReport\api\apiTestReport
#      jmeter -n -t $(Build.SourcesDirectory)/spring-boot-application-api-test.jmx -l $(Build.SourcesDirectory)/JMeterTestReport/api/ApiTest.xml -e -o $(Build.SourcesDirectory)/JMeterTestReport/api/apiTestReport/
#    displayName: Run TestApi JMeter script
#
#  # Python script which converts JMeter .xml format to JUnit .xml format, downloaded from git repository:
#  # https://github.com/Azure-Samples/jmeter-aci-terraform/blob/main/scripts/jtl_junit_converter.py
#  # IT IS A TOOL I DID NOT CREATE, author of this tool is git user: @davidmiguelalves
#  - script: |
#      curl https://raw.githubusercontent.com/Azure-Samples/jmeter-aci-terraform/main/scripts/jtl_junit_converter.py -o $(Build.SourcesDirectory)\jtl_junit_converter.py
#    displayName: Download xml formater, JMeter.xml to JUnit.xml format
#  
#  # converts the JMeter .jtl output from the test to a .xml file in JUnit standard via
#  # the python script downloaded earlier for displaying it in the azure tests tab.
#  - script: |
#      py jtl_junit_converter.py $(Build.SourcesDirectory)/JMeterTestReport/api/ApiTest.xml ApiTest.xml
#    displayName: Convert ApiTest.xml format
#  
#  # Publishes the results from the api, in the tests tab.
#  - task: PublishTestResults@2
#    inputs:
#      testResultsFormat: JUnit
#      testResultsFiles: $(Build.SourcesDirectory)/ApiTest.xml
#      testRunTitle: Api Test Results
#    displayName: Publishes API test results
#  
#  # Publishes the JMeter test report as an artifact so it can be downloaded and viewed.
#  - task: PublishBuildArtifacts@1
#    inputs:
#      PathtoPublish: $(Build.SourcesDirectory)/JMeterTestReport/api/apiTestReport/
#      ArtifactName: JMeter Api test results
#      publishLocation: Container
#    displayName: 'Upload JMeter Api test report'
#
####### TestingPerformance #############################################################################################################################
#
#- job: TestingPerformance
#  displayName: Tests the performance of the server apis
#  dependsOn: TestingAPI
#  
#  steps:
#  - checkout: none
#  
#  # initializes the directory for testresults and runs the JMeter test script.
#  - script: |
#      mkdir $(Build.SourcesDirectory)\JMeterTestReport\performance\performanceTestReport
#      jmeter -n -t $(Build.SourcesDirectory)/spring-boot-application-performance-test.jmx -l $(Build.SourcesDirectory)/JMeterTestReport/performance/PerformanceTest.xml -e -o $(Build.SourcesDirectory)/JMeterTestReport/performance/performanceTestReport/
#    displayName: Run TestApi JMeter script
#
#  # converts the JMeter .jtl output from the test to a .xml file in JUnit standard via
#  # the python script downloaded earlier for displaying it in the azure tests tab.
#  - script: |
#      py jtl_junit_converter.py $(Build.SourcesDirectory)/JMeterTestReport/performance/PerformanceTest.xml PerformanceTest.xml
#    displayName: Convert PerformanceTest.xml format
#  
#  # Publishes the results from the performance tests, in the tests tab.
#  - task: PublishTestResults@2
#    inputs:
#      testResultsFormat: JUnit
#      testResultsFiles: $(Build.SourcesDirectory)/PerformanceTest.xml
#      testRunTitle: Performance Test Results
#    displayName: Publishes performance test results
#  
#  # Publishes the JMeter test report as an artifact so it can be downloaded and viewed.
#  - task: PublishBuildArtifacts@1
#    inputs:
#      PathtoPublish: $(Build.SourcesDirectory)/JMeterTestReport/performance/performanceTestReport/
#      ArtifactName: JMeter performance test results
#      publishLocation: Container
#    displayName: 'Upload JMeter performance test report'
#
####### Clean ##########################################################################################################################################
#
## Clean always runs wether the pipeline fails or not.
## Deletes the docker images built, and running docker containers.
#- job: Clean
#  displayName: Clean docker
#  dependsOn: 
#    - BuildAndTest
#    - Dockerize
#    - TestingAPI
#    - TestingPerformance
#  condition: always()
#
#  steps:
#  # Deletes the docker image.
#  - script: |
#        docker rmi spring-boot-app:$(tag)
#    displayName: Remove docker image on agent  
#
#  # Deletes the docker container.
#  - script: |
#      docker rm --force spring-boot-app
#      docker image prune -f
#    displayName: Deletes the running container